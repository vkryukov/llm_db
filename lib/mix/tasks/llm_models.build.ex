defmodule Mix.Tasks.LlmModels.Build do
  use Mix.Task

  @shortdoc "Build snapshot.json from sources using the ETL pipeline"

  @moduledoc """
  Builds snapshot.json from configured sources using the Engine ETL pipeline.

  Runs the complete ETL pipeline (Ingest → Normalize → Validate → Merge →
  Enrich → Filter → Index) on configured sources to generate a fresh
  snapshot.json file.

  ## Usage

      mix llm_models.build

  ## Configuration

  Configure sources in your application config:

      config :llm_models,
        sources: [
          {LLMModels.Sources.Packaged, %{}},
          {LLMModels.Sources.ModelsDev, %{url: "https://models.dev/api.json"}},
          {LLMModels.Sources.JSONFile, %{paths: ["priv/custom.json"]}}
        ],
        allow: :all,
        deny: %{},
        prefer: [:openai, :anthropic]
  """

  @snapshot_path "priv/llm_models/snapshot.json"

  @impl Mix.Task
  def run(_args) do
    Mix.Task.run("app.start")

    Mix.shell().info("Building snapshot from configured sources...\n")

    {:ok, snapshot} = build_snapshot()
    save_snapshot(snapshot)
    print_summary(snapshot)
  end

  defp build_snapshot do
    config = LLMModels.Config.get()
    sources = LLMModels.Config.sources!()

    if sources == [] do
      Mix.shell().info("Warning: No sources configured - snapshot will be empty\n")
    end

    LLMModels.Engine.run(
      sources: sources,
      allow: config.allow,
      deny: config.deny,
      prefer: config.prefer
    )
  end

  defp save_snapshot(snapshot) do
    @snapshot_path
    |> Path.dirname()
    |> File.mkdir_p!()

    # V2 schema: nested providers with models
    output_data = %{
      "version" => snapshot.version,
      "generated_at" => snapshot.generated_at,
      "providers" => map_with_string_keys(snapshot.providers)
    }

    json = Jason.encode!(output_data, pretty: true)
    File.write!(@snapshot_path, json)

    Mix.shell().info("✓ Snapshot written to #{@snapshot_path} (v#{snapshot.version})")

    # Generate ValidProviders module from normalized snapshot data
    generate_valid_providers(snapshot)
  end

  defp print_summary(snapshot) do
    provider_count = map_size(snapshot.providers)

    model_count =
      snapshot.providers
      |> Map.values()
      |> Enum.map(fn provider -> map_size(provider.models) end)
      |> Enum.sum()

    Mix.shell().info("")
    Mix.shell().info("Summary:")
    Mix.shell().info("  Providers: #{provider_count}")
    Mix.shell().info("  Models: #{model_count}")
  end

  defp map_with_string_keys(map) when is_map(map) do
    Map.new(map, fn
      {k, v} when is_atom(k) -> {Atom.to_string(k), map_with_string_keys(v)}
      {k, v} -> {k, map_with_string_keys(v)}
    end)
  end

  defp map_with_string_keys(list) when is_list(list) do
    Enum.map(list, &map_with_string_keys/1)
  end

  defp map_with_string_keys(value), do: value

  # Generate ValidProviders module from normalized snapshot data
  defp generate_valid_providers(snapshot) do
    # Extract provider atoms from nested providers map
    provider_atoms =
      snapshot.providers
      |> Map.keys()
      |> Enum.sort()
      |> Enum.uniq()

    write_valid_providers_module(provider_atoms)
    Mix.shell().info("✓ Generated valid_providers.ex with #{length(provider_atoms)} providers")
  end

  # Write the ValidProviders module to disk
  defp write_valid_providers_module(provider_atoms) do
    module_code = """
    defmodule LLMModels.Generated.ValidProviders do
      @moduledoc \"\"\"
      Auto-generated module containing all valid provider atoms.

      This module is generated by `mix llm_models.build` to prevent atom leaking.
      By pre-generating all provider atoms at build time, we ensure that runtime
      code can only use existing atoms via `String.to_existing_atom/1`.

      DO NOT EDIT THIS FILE MANUALLY - it will be overwritten.
      \"\"\"

      @providers #{inspect(provider_atoms, limit: :infinity)}

      @doc \"\"\"
      Returns the list of all valid provider atoms.
      \"\"\"
      @spec list() :: [atom()]
      def list, do: @providers

      @doc \"\"\"
      Checks if the given atom is a valid provider.
      \"\"\"
      @spec member?(atom()) :: boolean()
      def member?(atom), do: atom in @providers
    end
    """

    module_path = "lib/llm_models/generated/valid_providers.ex"
    File.mkdir_p!(Path.dirname(module_path))
    formatted = Code.format_string!(module_code)
    File.write!(module_path, formatted)
  end
end
